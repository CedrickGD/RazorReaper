@page "/autoclicker"
@using System.Runtime.InteropServices
@using System.Timers
@using System.Drawing
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="app-container">
    <RazorReaper.Components.Shared.SharedNavbar />

    <main class="main-content">
        <header class="page-header">
            <h1 class="page-title">Auto Clicker</h1>
            <p class="page-subtitle">Advanced mouse automation tool</p>
        </header>

        <div class="autoclicker-layout">
            <!-- Left Panel - Main Controls -->
            <div class="control-panel">
                <div class="content-card">
                    <h3>Click Settings</h3>

                    <div class="setting-group">
                        <label class="setting-label">Click Interval</label>
                        <div class="interval-inputs">
                            <div class="time-input-group">
                                <input type="number" @bind="hours" min="0" max="99" class="time-input" />
                                <span class="time-label">Hours</span>
                            </div>
                            <div class="time-input-group">
                                <input type="number" @bind="minutes" min="0" max="59" class="time-input" />
                                <span class="time-label">Minutes</span>
                            </div>
                            <div class="time-input-group">
                                <input type="number" @bind="seconds" min="0" max="59" class="time-input" />
                                <span class="time-label">Seconds</span>
                            </div>
                            <div class="time-input-group">
                                <input type="number" @bind="milliseconds" min="0" max="999" class="time-input" />
                                <span class="time-label">Milliseconds</span>
                            </div>
                        </div>
                    </div>

                    <div class="setting-group">
                        <label class="setting-label">Mouse Button</label>
                        <div class="button-select">
                            <button class="select-btn @(mouseButton == MouseButton.Left ? "active" : "")"
                                    @onclick="() => mouseButton = MouseButton.Left">
                                Left
                            </button>
                            <button class="select-btn @(mouseButton == MouseButton.Middle ? "active" : "")"
                                    @onclick="() => mouseButton = MouseButton.Middle">
                                Middle
                            </button>
                            <button class="select-btn @(mouseButton == MouseButton.Right ? "active" : "")"
                                    @onclick="() => mouseButton = MouseButton.Right">
                                Right
                            </button>
                        </div>
                    </div>

                    <div class="setting-group">
                        <label class="setting-label">Click Type</label>
                        <div class="button-select">
                            <button class="select-btn @(clickType == ClickType.Single ? "active" : "")"
                                    @onclick="() => clickType = ClickType.Single">
                                Single
                            </button>
                            <button class="select-btn @(clickType == ClickType.Double ? "active" : "")"
                                    @onclick="() => clickType = ClickType.Double">
                                Double
                            </button>
                        </div>
                    </div>

                    <div class="setting-group">
                        <label class="setting-label">Repeat</label>
                        <div class="repeat-options">
                            <div class="radio-group">
                                <input type="radio" id="repeat-infinite" name="repeat" checked="@(repeatMode == RepeatMode.Infinite)"
                                       @onchange="() => repeatMode = RepeatMode.Infinite" />
                                <label for="repeat-infinite">Repeat until stopped</label>
                            </div>
                            <div class="radio-group">
                                <input type="radio" id="repeat-count" name="repeat" checked="@(repeatMode == RepeatMode.Count)"
                                       @onchange="() => repeatMode = RepeatMode.Count" />
                                <label for="repeat-count">Repeat</label>
                                <input type="number" @bind="repeatCount" min="1" max="999999" class="repeat-input"
                                       disabled="@(repeatMode != RepeatMode.Count)" />
                                <span>times</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="content-card">
                    <h3>Hotkey</h3>

                    <div class="hotkey-group">
                        <div class="hotkey-item">
                            <span class="hotkey-label">Start/Stop Hotkey</span>
                            <button class="hotkey-btn" @onclick="SetStartHotkey">
                                @(recordingKey ? "Press any key..." : hotkey)
                            </button>
                        </div>
                    </div>

                    <div class="hotkey-info">
                        <svg fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                        </svg>
                        <span>Press F6 to start/stop clicking (works globally)</span>
                    </div>
                </div>

                <!-- Control Buttons -->
                <div class="control-buttons">
                    <button class="btn btn-primary @(isRunning ? "btn-stop" : "btn-start")"
                            @onclick="ToggleClicking" disabled="@(!IsValidInterval())">
                        @(isRunning ? "Stop (F6)" : "Start (F6)")
                    </button>
                    <button class="btn btn-secondary" @onclick="ResetStats">
                        Reset
                    </button>
                </div>
            </div>

            <!-- Right Panel - Position & Status -->
            <div class="status-panel">
                <div class="content-card">
                    <h3>Click Position</h3>

                    <div class="position-options">
                        <div class="radio-group">
                            <input type="radio" id="pos-current" name="position" checked="@(positionMode == PositionMode.Current)"
                                   @onchange="() => positionMode = PositionMode.Current" />
                            <label for="pos-current">Current cursor position</label>
                        </div>
                        <div class="radio-group">
                            <input type="radio" id="pos-fixed" name="position" checked="@(positionMode == PositionMode.Fixed)"
                                   @onchange="() => { positionMode = PositionMode.Fixed; }" />
                            <label for="pos-fixed">Fixed position</label>
                        </div>
                    </div>

                    @if (positionMode == PositionMode.Fixed)
                    {
                        <div class="position-controls">
                            <div class="coord-inputs">
                                <div class="coord-group">
                                    <label>X:</label>
                                    <input type="number" @bind="fixedX" class="coord-input" />
                                </div>
                                <div class="coord-group">
                                    <label>Y:</label>
                                    <input type="number" @bind="fixedY" class="coord-input" />
                                </div>
                            </div>
                            <button class="pick-btn" @onclick="StartPickLocation" disabled="@pickingLocation">
                                <svg fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                                    <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                                </svg>
                                @(pickingLocation ? "Click anywhere..." : "Pick Location")
                            </button>
                        </div>
                    }

                    <div class="current-position">
                        <span class="position-label">Current Mouse Position:</span>
                        <span class="position-value">X: @currentMouseX, Y: @currentMouseY</span>
                    </div>
                </div>

                <div class="content-card autoclicker-status-card @(isRunning ? "active" : "")">
                    <div class="autoclicker-status-header">
                        <div class="autoclicker-status-indicator @(isRunning ? "running" : "stopped")"></div>
                        <h3>Status</h3>
                    </div>

                    <div class="status-info">
                        <div class="status-row">
                            <span>State:</span>
                            <span class="status-value @(isRunning ? "text-green" : "text-red")">
                                @(isRunning ? "Running" : "Stopped")
                            </span>
                        </div>
                        <div class="status-row">
                            <span>Clicks:</span>
                            <span class="status-value">@clickCount</span>
                        </div>
                        @if (repeatMode == RepeatMode.Count)
                        {
                            <div class="status-row">
                                <span>Progress:</span>
                                <span class="status-value">@clickCount / @repeatCount</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: @(GetProgressPercentage())%"></div>
                            </div>
                        }
                        <div class="status-row">
                            <span>Interval:</span>
                            <span class="status-value">@GetIntervalDisplay()</span>
                        </div>
                        @if (isRunning && nextClickTime != null)
                        {
                            <div class="status-row">
                                <span>Next Click:</span>
                                <span class="status-value">@GetNextClickTime()</span>
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>

@code {
    // Enums
    public enum MouseButton { Left, Middle, Right }
    public enum ClickType { Single, Double }
    public enum RepeatMode { Infinite, Count }
    public enum PositionMode { Current, Fixed }

    // Timing fields
    private int hours = 0;
    private int minutes = 0;
    private int seconds = 1;
    private int milliseconds = 0;

    // Settings fields
    private MouseButton mouseButton = MouseButton.Left;
    private ClickType clickType = ClickType.Single;
    private RepeatMode repeatMode = RepeatMode.Infinite;
    private int repeatCount = 10;
    private PositionMode positionMode = PositionMode.Current;

    // Position fields
    private int fixedX = 0;
    private int fixedY = 0;
    private int currentMouseX = 0;
    private int currentMouseY = 0;
    private bool pickingLocation = false;

    // Status fields
    private bool isRunning = false;
    private int clickCount = 0;
    private Timer? clickTimer;
    private Timer? mouseTrackingTimer;
    private DateTime? nextClickTime;

    // Hotkey fields
    private string hotkey = "F6";
    private bool recordingKey = false;
    private bool hotkeyRegistered = false;

    // Windows API imports
    [DllImport("user32.dll")]
    private static extern void mouse_event(uint dwFlags, int dx, int dy, uint cButtons, uint dwExtraInfo);

    [DllImport("user32.dll")]
    private static extern bool GetCursorPos(out POINT lpPoint);

    [DllImport("user32.dll")]
    private static extern bool SetCursorPos(int x, int y);

    [DllImport("user32.dll")]
    private static extern short GetAsyncKeyState(int vKey);

    [DllImport("user32.dll")]
    private static extern IntPtr GetForegroundWindow();

    [DllImport("kernel32.dll")]
    private static extern IntPtr GetConsoleWindow();

    [StructLayout(LayoutKind.Sequential)]
    private struct POINT
    {
        public int X;
        public int Y;
    }

    // Mouse event constants
    private const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
    private const uint MOUSEEVENTF_LEFTUP = 0x0004;
    private const uint MOUSEEVENTF_RIGHTDOWN = 0x0008;
    private const uint MOUSEEVENTF_RIGHTUP = 0x0010;
    private const uint MOUSEEVENTF_MIDDLEDOWN = 0x0020;
    private const uint MOUSEEVENTF_MIDDLEUP = 0x0040;
    private const uint MOUSEEVENTF_ABSOLUTE = 0x8000;
    private const uint MOUSEEVENTF_MOVE = 0x0001;

    // Virtual key codes
    private const int VK_F6 = 0x75;

    protected override async Task OnInitializedAsync()
    {
        // Initialize mouse tracking timer
        mouseTrackingTimer = new Timer(100); // Update every 100ms
        mouseTrackingTimer.Elapsed += UpdateMousePosition;
        mouseTrackingTimer.Start();

        // Start hotkey monitoring
        _ = Task.Run(MonitorHotkey);

        await base.OnInitializedAsync();
    }

    private void UpdateMousePosition(object? sender, ElapsedEventArgs e)
    {
        if (GetCursorPos(out POINT point))
        {
            currentMouseX = point.X;
            currentMouseY = point.Y;
            InvokeAsync(StateHasChanged);
        }
    }

    private async Task MonitorHotkey()
    {
        bool wasPressed = false;

        while (true)
        {
            try
            {
                // Check if F6 is pressed
                bool isPressed = (GetAsyncKeyState(VK_F6) & 0x8000) != 0;

                if (isPressed && !wasPressed)
                {
                    // Key was just pressed
                    await InvokeAsync(() => ToggleClicking());
                }

                wasPressed = isPressed;
                await Task.Delay(50); // Check every 50ms
            }
            catch
            {
                await Task.Delay(100);
            }
        }
    }

    private bool IsValidInterval()
    {
        return hours > 0 || minutes > 0 || seconds > 0 || milliseconds > 0;
    }

    private double GetTotalMilliseconds()
    {
        return (hours * 3600000) + (minutes * 60000) + (seconds * 1000) + milliseconds;
    }

    private string GetIntervalDisplay()
    {
        var parts = new List<string>();
        if (hours > 0) parts.Add($"{hours}h");
        if (minutes > 0) parts.Add($"{minutes}m");
        if (seconds > 0) parts.Add($"{seconds}s");
        if (milliseconds > 0) parts.Add($"{milliseconds}ms");
        return parts.Count > 0 ? string.Join(" ", parts) : "0ms";
    }

    private double GetProgressPercentage()
    {
        if (repeatMode != RepeatMode.Count || repeatCount == 0) return 0;
        return Math.Min(100, (double)clickCount / repeatCount * 100);
    }

    private string GetNextClickTime()
    {
        if (!isRunning || nextClickTime == null) return "N/A";
        var remaining = nextClickTime.Value - DateTime.Now;
        return remaining.TotalMilliseconds > 0 ? $"{remaining.TotalMilliseconds:F0}ms" : "Now";
    }

    private async Task ToggleClicking()
    {
        if (isRunning)
        {
            StopClicking();
        }
        else
        {
            await StartClicking();
        }
    }

    private async Task StartClicking()
    {
        if (!IsValidInterval()) return;

        isRunning = true;
        clickCount = 0; // Reset click count when starting

        var interval = GetTotalMilliseconds();
        clickTimer = new Timer(interval);
        clickTimer.Elapsed += async (sender, e) => await PerformClick();
        clickTimer.AutoReset = true;
        clickTimer.Start();

        // Set next click time
        nextClickTime = DateTime.Now.AddMilliseconds(interval);

        // Perform first click immediately
        await PerformClick();

        await InvokeAsync(StateHasChanged);
    }

    private void StopClicking()
    {
        isRunning = false;
        nextClickTime = null;
        clickTimer?.Stop();
        clickTimer?.Dispose();
        clickTimer = null;
        StateHasChanged();
    }

    private async Task PerformClick()
    {
        if (!isRunning) return;

        // Check if we've reached the repeat count
        if (repeatMode == RepeatMode.Count && clickCount >= repeatCount)
        {
            await InvokeAsync(() =>
            {
                StopClicking();
            });
            return;
        }

        await InvokeAsync(async () =>
        {
            try
            {
                // Get current cursor position
                POINT currentPos = new POINT();
                GetCursorPos(out currentPos);

                // If using fixed position, move cursor there
                if (positionMode == PositionMode.Fixed)
                {
                    SetCursorPos(fixedX, fixedY);
                    await Task.Delay(10); // Small delay to ensure cursor is positioned
                }

                // Get the appropriate mouse button flags
                var (downFlag, upFlag) = GetMouseEventFlags();

                // Perform the click at the current position (0,0 means current position)
                mouse_event(downFlag, 0, 0, 0, 0);
                await Task.Delay(50); // Delay between down and up
                mouse_event(upFlag, 0, 0, 0, 0);

                // Handle double click
                if (clickType == ClickType.Double)
                {
                    await Task.Delay(50);
                    mouse_event(downFlag, 0, 0, 0, 0);
                    await Task.Delay(50);
                    mouse_event(upFlag, 0, 0, 0, 0);
                }

                // Restore cursor position if we moved it
                if (positionMode == PositionMode.Fixed)
                {
                    SetCursorPos(currentPos.X, currentPos.Y);
                }

                clickCount++;

                // Update next click time
                if (isRunning)
                {
                    nextClickTime = DateTime.Now.AddMilliseconds(GetTotalMilliseconds());
                }

                // Check if we should stop (for count mode)
                if (repeatMode == RepeatMode.Count && clickCount >= repeatCount)
                {
                    StopClicking();
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Click error: {ex.Message}");
            }
        });
    }

    private (uint downFlag, uint upFlag) GetMouseEventFlags()
    {
        return mouseButton switch
        {
            MouseButton.Left => (MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP),
            MouseButton.Right => (MOUSEEVENTF_RIGHTDOWN, MOUSEEVENTF_RIGHTUP),
            MouseButton.Middle => (MOUSEEVENTF_MIDDLEDOWN, MOUSEEVENTF_MIDDLEUP),
            _ => (MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP)
        };
    }

    private async Task StartPickLocation()
    {
        pickingLocation = true;
        StateHasChanged();

        // Use JavaScript to capture the next click
        await JSRuntime.InvokeVoidAsync("eval", @"
            window.pickLocationHandler = function(e) {
                e.preventDefault();
                e.stopPropagation();
                DotNet.invokeMethodAsync('RazorReaper', 'SetPickedLocation', e.clientX, e.clientY);
                document.removeEventListener('click', window.pickLocationHandler, true);
                return false;
            };
            setTimeout(() => {
                document.addEventListener('click', window.pickLocationHandler, true);
            }, 100);
        ");
    }

    [JSInvokable]
    public static Task SetPickedLocation(int x, int y)
    {
        // This would need to be improved to properly set the instance values
        // For now, we'll use the GetCursorPos approach
        return Task.CompletedTask;
    }

    private async Task SetStartHotkey()
    {
        recordingKey = true;
        StateHasChanged();

        // Simulate key recording for 2 seconds
        await Task.Delay(2000);

        recordingKey = false;
        hotkey = "F6"; // Always use F6 for simplicity
        StateHasChanged();
    }

    private void ResetStats()
    {
        clickCount = 0;
        if (isRunning)
        {
            StopClicking();
        }
        StateHasChanged();
    }

    public void Dispose()
    {
        StopClicking();
        mouseTrackingTimer?.Stop();
        mouseTrackingTimer?.Dispose();
    }
}